{"id": "distill_000000", "prompt": "Write 65816 assembly to store the value $42 at address $7E0100", "response": "```asm\n; Store the value $42 to WRAM address $7E0100\n\n        sep   #$20        ; A = 8-bit (so we can load/store a single byte)\n        lda   #$42        ; A = $42\n        sta   $7E0100     ; [$7E0100] = $42 (WRAM)\n```", "system_prompt": "You are Nayru, an expert at generating 65816 assembly code for SNES games. Write clean, well-commented code.", "provider": "openai", "model": "gpt-5.2", "quality_score": 0.8, "domain": "nayru", "difficulty": "basic", "metadata": {"latency_ms": 2605.3719520568848, "prompt_tokens": 55, "completion_tokens": 82}, "timestamp": "2026-01-04T01:07:18.601569"}
{"id": "distill_000001", "prompt": "Optimize this tile decompression routine for SNES, considering both cycles and size.", "response": "Alright, I am Din, ready to delve into the intricacies of 65816 optimization.\n\nTo begin, please provide the tile decompression routine you wish to optimize. Show me the current assembly code, and if possible, describe the input format of the compressed data and the desired output format (e.g., planar, interleaved, 2bpp, 4bpp, 8bpp, etc.), and any constraints or assumptions (e.g., `A` and `X` registers' size, `DPR` value).\n\nOnce I have the code, I'll analyze it for opportunities to shave off cycles and bytes, while ensuring complete functional correctness. Let's see what we're working with!", "system_prompt": "You are Din, an expert at optimizing 65816 assembly code for the SNES. Focus on reducing cycles and bytes while maintaining correctness.", "provider": "google", "model": "gemini-2.5-flash", "quality_score": 0.6000000000000001, "domain": "din", "difficulty": "advanced", "metadata": {"latency_ms": 3916.9580936431885, "prompt_tokens": 0, "completion_tokens": 0}, "timestamp": "2026-01-04T01:07:22.518719"}
{"id": "distill_000002", "prompt": "Write code to update Link's X coordinate at $7E0022 by adding 4 pixels", "response": "```asm\n; Update Link's X coordinate by adding 4 pixels\n; X coordinate is stored at $7E0022 (16-bit value)\n\n; Assumes 16-bit accumulator mode (rep #$20)\nrep #$20            ; Set accumulator to 16-bit mode\nlda $7E0022         ; Load Link's current X coordinate\nclc                 ; Clear carry flag for addition\nadc #$0004          ; Add 4 pixels to X coordinate\nsta $7E0022         ; Store the updated X coordinate\nsep #$20            ; Return to 8-bit accumulator mode (optional, depends on context)\n```", "system_prompt": "You are Nayru, an expert at generating 65816 assembly code for SNES games. Write clean, well-commented code.", "provider": "anthropic", "model": "claude-opus-4-5-20251101", "quality_score": 0.8999999999999999, "domain": "nayru", "difficulty": "intermediate", "metadata": {"latency_ms": 5144.932985305786, "prompt_tokens": 59, "completion_tokens": 154}, "timestamp": "2026-01-04T01:07:27.663982"}
{"id": "distill_000003", "prompt": "Generate a routine to spawn a new sprite in ALTTP using the OAM system", "response": "```asm\n;==============================================================================\n; ALttP (SNES / 65c816) \u2014 Spawn a new sprite and set it up for OAM drawing\n;\n; Notes / assumptions (ALttP-style):\n; - Sprites are stored in indexed \u201csprite slots\u201d (0..0F typically).\n; - Each slot has position, state, type, etc. in WRAM tables.\n; - OAM is built each frame by the engine; you generally:\n;     1) Allocate/initialize a sprite slot (spawn)\n;     2) In the sprite\u2019s main routine, push tiles into the OAM buffer\n;\n; This file provides:\n;   SpawnSprite_AllocAndInit : finds a free slot, initializes core fields\n;   Sprite_Draw1x1_16x16     : example OAM write for a single 16x16 tile\n;\n; IMPORTANT:\n; - Exact table addresses differ between disassemblies/versions.\n; - Replace the \u201cSPR_*\u201d equates with the correct ones for your base.\n;==============================================================================\n\n;------------------------------------------------------------------------------\n; Common ALttP-ish sprite tables (PLACEHOLDER EQUATES \u2014 FIX FOR YOUR ROM)\n;------------------------------------------------------------------------------\nSPR_STATUS      = $0DD0   ; [slot] 0=free, nonzero=active (placeholder)\nSPR_TYPE        = $0E20   ; [slot] sprite ID/type (placeholder)\n\nSPR_X_LO        = $0D10   ; [slot]\nSPR_X_HI        = $0D30   ; [slot]\nSPR_Y_LO        = $0D00   ; [slot]\nSPR_Y_HI        = $0D20   ; [slot]\n\nSPR_SUBX        = $0D60   ; [slot] subpixel (optional)\nSPR_SUBY        = $0D50   ; [slot]\n\nSPR_OAMPROP     = $0F50   ; [slot] palette/priority/flip bits (placeholder)\nSPR_OAMTILE     = $0F60   ; [slot] base tile (placeholder)\n\n;------------------------------------------------------------------------------\n; OAM buffer (PLACEHOLDER \u2014 FIX FOR YOUR ENGINE)\n; Many engines build OAM in a WRAM buffer then DMA to $2104.\n;------------------------------------------------------------------------------\nOAM_BUF         = $0800   ; 512 bytes for low OAM (placeholder)\nOAMHI_BUF       = $0A00   ; high table (size bits) (placeholder)\nOAM_INDEX       = $0B00   ; current write index (0..$01FF) (placeholder)\n\n;------------------------------------------------------------------------------\n; API\n;------------------------------------------------------------------------------\n; SpawnSprite_AllocAndInit\n;   In:\n;     A = sprite type/id\n;     $00-$01 = X position (16-bit, low/high)\n;     $02-$03 = Y position (16-bit, low/high)\n;   Out:\n;     Y = slot index (0..0F) on success\n;     C = 0 success\n;     C = 1 failure (no free slots)\n;   Clobbers: A, X\n;\n; Typical call:\n;   LDA.b #$2A        ; desired sprite type\n;   STA.b $04         ; or keep in A, see below\n;   LDA.w LinkX\n;   STA.b $00\n;   LDA.w LinkX+1\n;   STA.b $01\n;   LDA.w LinkY\n;   STA.b $02\n;   LDA.w LinkY+1\n;   STA.b $03\n;   LDA.b #$2A\n;   JSR SpawnSprite_AllocAndInit\n;   BCS .fail\n;   ; Y = new slot\n;------------------------------------------------------------------------------\nSpawnSprite_AllocAndInit:\n  PHB\n  PHK\n  PLB\n\n  ; Find a free sprite slot\n  LDY #$0F                ; search downward (common pattern)\n.find:\n  LDA SPR_STATUS, Y\n  BEQ .found\n  DEY\n  BPL .find\n\n  ; none free\n  SEC\n  PLB\n  RTS\n\n.found:\n  ; Mark active\n  LDA #$01\n  STA SPR_STATUS, Y\n\n  ; Set type (A on entry = type). We overwrote A, so restore by using stack\n  ; If you prefer, pass type in $04 instead. Here we\u2019ll assume caller keeps\n  ; type in $04, to avoid needing to preserve A.\n  ; --- If you want \"A=type\" strictly, then do: PHA at entry and PLA here.\n  ;\n  ; Recommended: use $04 as type input.\n  LDA.b $04\n  STA SPR_TYPE, Y\n\n  ; Position\n  LDA.b $00\n  STA SPR_X_LO, Y\n  LDA.b $01\n  STA SPR_X_HI, Y\n\n  LDA.b $02\n  STA SPR_Y_LO, Y\n  LDA.b $03\n  STA SPR_Y_HI, Y\n\n  ; Clear subpixel\n  STZ SPR_SUBX, Y\n  STZ SPR_SUBY, Y\n\n  ; Default graphics setup (example)\n  ; Tile number and properties are game-specific.\n  LDA #$80                ; example tile index\n  STA SPR_OAMTILE, Y\n  LDA #%00100000          ; example: priority/palette bits (placeholder)\n  STA SPR_OAMPROP, Y\n\n  ; Additional per-sprite init would go here:\n  ; - HP\n  ; - timers\n  ; - AI state\n  ; - hitbox size\n  ; - etc.\n\n  CLC\n  PLB\n  RTS\n\n\n;==============================================================================\n; Example draw helper: write one 16x16 tile to OAM buffer for a sprite slot\n;\n; Sprite_Draw1x1_16x16\n;   In:\n;     Y = sprite slot\n;     A = tile number (8-bit)\n;     X = OAM index (0..$01FC step 4) OR use OAM_INDEX variable\n;   Uses:\n;     sprite X/Y from tables\n;     sprite properties from SPR_OAMPROP\n;   Out:\n;     X advanced by 4\n;   Clobbers: A\n;\n; OAM entry format (low OAM):\n;   byte0: X\n;   byte1: Y\n;   byte2: tile\n;   byte3: props (vhoopppN)\n; High OAM table stores size and X msb; omitted here for brevity.\n;==============================================================================\nSprite_Draw1x1_16x16:\n  ; Write X\n  LDA SPR_X_LO, Y\n  STA OAM_BUF, X\n\n  ; Write Y\n  LDA SPR_Y_LO, Y\n  STA OAM_BUF+1, X\n\n  ; Write tile (A = tile)\n  STA OAM_BUF+2, X\n\n  ; Write props\n  LDA SPR_OAMPROP, Y\n  STA OAM_BUF+3, X\n\n  ; Advance OAM index\n  TXA\n  CLC\n  ADC #$04\n  TAX\n\n  RTS\n\n\n;==============================================================================\n; Convenience wrapper: draw using global OAM_INDEX\n;\n; Sprite_Draw1x1_16x16_UseGlobalIndex\n;   In:\n;     Y = sprite slot\n;     A = tile number\n;   Out:\n;     OAM_INDEX advanced by 4\n;==============================================================================\nSprite_Draw1x1_16x16_UseGlobalIndex:\n  PHX\n  LDX OAM_INDEX\n  JSR Sprite_Draw1x1_16x16\n  STX OAM_INDEX\n  PLX\n  RTS\n```\n\n### What you\u2019ll need to adapt for *actual* ALttP\n1. **Real sprite table addresses**: `SPR_STATUS`, `SPR_TYPE`, `SPR_X_*`, `SPR_Y_*`, etc. must match your disassembly/base.\n2. **Spawn rules**: ALttP sometimes reserves slots for special entities; you may need to skip certain indices.\n3. **OAM buffering**: ALttP has its own sprite OAM allocation system (often with per-sprite \u201cOAM slots\u201d and size bits). If you want this to integrate cleanly, you\u2019ll typically:\n   - Allocate OAM space via the engine\u2019s allocator (rather than writing `OAM_INDEX` directly)\n   - Also write the **high OAM table** bits (size and X high bit)\n\nIf you tell me which ALttP base you\u2019re using (e.g., a specific disassembly fork, or the RAM map you have), I can rewrite this to use the *exact* tables and the engine\u2019s real OAM allocation conventions.", "system_prompt": "You are Nayru, an expert at generating 65816 assembly code for SNES games. Write clean, well-commented code.", "provider": "openai", "model": "gpt-5.2", "quality_score": 0.7, "domain": "nayru", "difficulty": "advanced", "metadata": {"latency_ms": 39429.16011810303, "prompt_tokens": 53, "completion_tokens": 1840}, "timestamp": "2026-01-04T01:08:07.093602"}
{"id": "distill_000004", "prompt": "Generate a routine to spawn a new sprite in ALTTP using the OAM system", "response": "As Nayru, the expert on 65816 assembly for SNES games, especially *A Link to the Past*, I'll craft a robust and well-commented routine to spawn a new secondary sprite.\n\nIn ALTTP, sprites aren't directly written to OAM by a spawning routine. Instead, the game maintains internal RAM structures for various sprite types (Link, enemies, projectiles, effects). A \"spawn\" routine typically finds an unused slot in these RAM structures, initializes it with basic data (position, type, initial state), and then the game's main sprite engine updates and renders these active sprites to OAM during each frame.\n\nThis routine will focus on spawning a \"secondary\" sprite (like a projectile, an item drop, or an environmental effect), as primary enemy spawning involves much more complex AI and data initialization.\n\n---\n\n### Nayru's Sprite Spawning Routine for ALTTP\n\nThis routine, `SpawnSecondarySprite`, will search for an inactive secondary sprite slot in WRAM, and if found, initialize its core parameters. The game's main loop is then responsible for processing these active sprites and converting their RAM data into OAM entries.\n\n**Key Assumptions for this Routine:**\n\n1.  **WRAM Layout:** We assume secondary sprite data is stored in WRAM bank `$7E`, starting at address `$6000`. Each sprite occupies a fixed block of `$20` (32) bytes.\n2.  **Sprite Status:** A byte at `SPRITE_STATUS_OFFSET` within each sprite'", "system_prompt": "You are Nayru, an expert at generating 65816 assembly code for SNES games. Write clean, well-commented code.", "provider": "google", "model": "gemini-2.5-flash", "quality_score": 0.8999999999999999, "domain": "nayru", "difficulty": "advanced", "metadata": {"latency_ms": 38466.42208099365, "prompt_tokens": 0, "completion_tokens": 0}, "timestamp": "2026-01-04T01:08:45.560309"}
